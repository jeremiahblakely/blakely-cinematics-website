cat > /tmp/mail-manage-index.js << 'EOF'
// mail-manage Lambda Function
// Updated: December 17, 2024 8:45 PM
// Handles email operations: move to folders, mark read/unread, star, archive

const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, PutCommand, UpdateCommand, DeleteCommand, GetCommand } = require('@aws-sdk/lib-dynamodb');

const ddbClient = new DynamoDBClient({ region: 'us-east-1' });
const docClient = DynamoDBDocumentClient.from(ddbClient);

exports.handler = async (event) => {
    console.log('Received event:', JSON.stringify(event, null, 2));
    
    try {
        const httpMethod = event.httpMethod || event.requestContext?.http?.method || 'POST';
        
        // Handle DELETE requests - move to trash, not permanent delete
        if (httpMethod === 'DELETE') {
            const pathParams = event.pathParameters || {};
            const queryParams = event.queryStringParameters || {};
            
            const emailId = pathParams.id || pathParams.proxy || event.path?.split('/').pop();
            const userId = queryParams.userId || 'admin';
            
            // Move to trash instead of deleting
            return await moveToFolder({ 
                userId, 
                emailId, 
                targetFolder: 'trash' 
            });
        }
        
        // Handle POST requests with body
        const body = typeof event.body === 'string' ? JSON.parse(event.body) : event.body || {};
        const action = body.action || 'save-draft';
        
        switch(action) {
            case 'save-draft':
                return await saveDraft(body);
            case 'move-folder':
                return await moveToFolder(body);
            case 'delete-email':
                // This also moves to trash, not permanent delete
                return await moveToFolder({
                    userId: body.userId,
                    emailId: body.emailId,
                    targetFolder: 'trash'
                });
            case 'permanent-delete':
                // Only use this for permanent deletion from trash
                return await permanentlyDelete(body);
            case 'mark-read':
                return await markAsRead(body);
            case 'mark-unread':
                return await markAsUnread(body);
            case 'toggle-star':
                return await toggleStar(body);
            case 'archive':
                return await moveToFolder({
                    userId: body.userId,
                    emailId: body.emailId,
                    targetFolder: 'archive'
                });
            case 'restore':
                return await restoreFromTrash(body);
            default:
                return createResponse(400, {
                    success: false,
                    error: `Unknown action: ${action}`
                });
        }
    } catch (error) {
        console.error('Error:', error);
        return createResponse(500, {
            success: false,
            error: error.message || 'Internal server error'
        });
    }
};

async function saveDraft(data) {
    const emailId = data.emailId || `draft-${Date.now()}`;
    const params = {
        TableName: 'blakely-cinematics-emails',
        Item: {
            userId: data.userId || 'admin',
            emailId: emailId,
            folder: 'drafts',
            subject: data.subject || '(No Subject)',
            from: data.from || 'admin@blakelycinematics.com',
            to: data.to || [],
            cc: data.cc || [],
            bcc: data.bcc || [],
            htmlBody: data.htmlBody || '',
            textBody: data.textBody || '',
            timestamp: new Date().toISOString(),
            status: 'draft',
            starred: false,
            lastModified: new Date().toISOString()
        }
    };
    
    const command = new PutCommand(params);
    await docClient.send(command);
    
    return createResponse(200, {
        success: true,
        message: 'Draft saved',
        emailId: emailId
    });
}

async function moveToFolder(data) {
    // First, get the current email to preserve data
    const getParams = {
        TableName: 'blakely-cinematics-emails',
        Key: {
            userId: data.userId || 'admin',
            emailId: data.emailId
        }
    };
    
    const getCommand = new GetCommand(getParams);
    const currentEmail = await docClient.send(getCommand);
    
    // Store original folder for restore operations
    const originalFolder = currentEmail.Item?.folder || 'inbox';
    
    // Update the folder
    const params = {
        TableName: 'blakely-cinematics-emails',
        Key: {
            userId: data.userId || 'admin',
            emailId: data.emailId
        },
        UpdateExpression: 'SET folder = :folder, lastModified = :modified, originalFolder = :original',
        ExpressionAttributeValues: {
            ':folder': data.targetFolder,
            ':modified': new Date().toISOString(),
            ':original': data.targetFolder === 'trash' ? originalFolder : (currentEmail.Item?.originalFolder || originalFolder)
        },
        ReturnValues: 'ALL_NEW'
    };
    
    const command = new UpdateCommand(params);
    const result = await docClient.send(command);
    
    return createResponse(200, {
        success: true,
        message: `Email moved to ${data.targetFolder}`,
        email: result.Attributes
    });
}

async function permanentlyDelete(data) {
    // This permanently removes from DynamoDB - use with caution
    const params = {
        TableName: 'blakely-cinematics-emails',
        Key: {
            userId: data.userId || 'admin',
            emailId: data.emailId
        }
    };
    
    const command = new DeleteCommand(params);
    await docClient.send(command);
    
    return createResponse(200, {
        success: true,
        message: 'Email permanently deleted'
    });
}

async function restoreFromTrash(data) {
    // Get the email to find its original folder
    const getParams = {
        TableName: 'blakely-cinematics-emails',
        Key: {
            userId: data.userId || 'admin',
            emailId: data.emailId
        }
    };
    
    const getCommand = new GetCommand(getParams);
    const email = await docClient.send(getCommand);
    
    const targetFolder = email.Item?.originalFolder || data.targetFolder || 'inbox';
    
    return await moveToFolder({
        userId: data.userId,
        emailId: data.emailId,
        targetFolder: targetFolder
    });
}

async function markAsRead(data) {
    const params = {
        TableName: 'blakely-cinematics-emails',
        Key: {
            userId: data.userId || 'admin',
            emailId: data.emailId
        },
        UpdateExpression: 'SET #status = :status, lastModified = :modified',
        ExpressionAttributeNames: {
            '#status': 'status'
        },
        ExpressionAttributeValues: {
            ':status': 'read',
            ':modified': new Date().toISOString()
        },
        ReturnValues: 'ALL_NEW'
    };
    
    const command = new UpdateCommand(params);
    const result = await docClient.send(command);
    
    return createResponse(200, {
        success: true,
        message: 'Email marked as read',
        email: result.Attributes
    });
}

async function markAsUnread(data) {
    const params = {
        TableName: 'blakely-cinematics-emails',
        Key: {
            userId: data.userId || 'admin',
            emailId: data.emailId
        },
        UpdateExpression: 'SET #status = :status, lastModified = :modified',
        ExpressionAttributeNames: {
            '#status': 'status'
        },
        ExpressionAttributeValues: {
            ':status': 'unread',
            ':modified': new Date().toISOString()
        },
        ReturnValues: 'ALL_NEW'
    };
    
    const command = new UpdateCommand(params);
    const result = await docClient.send(command);
    
    return createResponse(200, {
        success: true,
        message: 'Email marked as unread',
        email: result.Attributes
    });
}

async function toggleStar(data) {
    // First get current star status
    const getParams = {
        TableName: 'blakely-cinematics-emails',
        Key: {
            userId: data.userId || 'admin',
            emailId: data.emailId
        }
    };
    
    const getCommand = new GetCommand(getParams);
    const current = await docClient.send(getCommand);
    const currentStarred = current.Item?.starred || false;
    
    // Toggle the star
    const params = {
        TableName: 'blakely-cinematics-emails',
        Key: {
            userId: data.userId || 'admin',
            emailId: data.emailId
        },
        UpdateExpression: 'SET starred = :starred, lastModified = :modified',
        ExpressionAttributeValues: {
            ':starred': !currentStarred,
            ':modified': new Date().toISOString()
        },
        ReturnValues: 'ALL_NEW'
    };
    
    const command = new UpdateCommand(params);
    const result = await docClient.send(command);
    
    return createResponse(200, {
        success: true,
        message: `Email ${!currentStarred ? 'starred' : 'unstarred'}`,
        email: result.Attributes
    });
}

function createResponse(statusCode, body) {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
            'Access-Control-Allow-Methods': 'GET,POST,DELETE,OPTIONS'
        },
        body: JSON.stringify(body)
    };
}
EOF